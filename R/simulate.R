#' Simulate the spread of COVID-19 through Australia
#' @description
#' Simulates the spread of COVID-19 given today's condition, and
#' the (imputed) distribution of indivdiuals among households,
#' schools, and other places, from day to day.
#'
#'
#' @param days_to_simulate \describe{
#' \item{\code{integer(1)}}{The number of days to simulate.}
#' }
#' @param InitialStatus \describe{
#' \item{\code{list()}}{If \code{NULL}, the default, the initial status
#' is set by the most recent data.
#'
#' Otherwise,
#' .}
#' }
#' @param PolicyPars \describe{
#' \item{\code{list()}}{A list describing the policy parameters.
#' (\code{list(schools_open = TRUE|FALSE, only_Year12 = TRUE|FALSE)}
#' are supported but no others. An empty list corresponds to current settings.)}
#' }
#'
#' @param MultiPolicy A list of \code{PolicyPars}.
#'
#' @param EpiPars \describe{
#' \item{\code{list()}}{A list of epidemiological parameters generated by \code{\link{set_epipars}}.}
#' }
#' @param .first_day \describe{
#' \item{\code{integer(1)}}{The first day to model.
#' If \code{NULL}, the default, the day of the year of the most recent date
#' in records from Australia. Used to predict the outcomes of those presently
#' ill with COVID-19 based on imputed duration of infection.}
#' }
#' @param showProgress Should progress times and bars be displayed?
#' By default, 1 which displays bars unless it is likely to not be
#' desired (for example it won't be displayed when running tests or
#' in non-interactive sessions). Set to 0 to never display; 2 to always
#' display. Set to 3 to also show internal data access.
#'
#'
#' @param dataEnv An environment into which the data will be saved and
#' retrieved. Used to save time reading after the first time.
#'
#' @param use_dataEnv \code{FALSE|TRUE} Whether or not to save the
#' underlying Australia table to \code{dataEnv} (and retrieve it on
#' subsequent uses).
#'
#' @param nThread \describe{
#' \item{\code{integer(1)}}{Number of threads to use in the C++ code.}
#' }
#'
#' @param myaus A prepared \code{data.table} with a column \code{status}
#' that has the desired distribution (including perhaps over SA2). This
#' formal is experimental and may be removed without notice.
#'
#' @param returner What values to return.
#' \describe{
#' \item{\code{0}}{The default, return the full data: status of each person, each day.}
#' \item{\code{1}}{\code{days} x \code{state} x \code{age} x \code{status}.}
#' }
#'
#' @return
#' A list of \code{days_to_simulate + 1} components. The first
#' component is the inital status of each individual and
#' subsequent components are the statuses of each day simulated.
#'
#' @details
#' The \strong{Status} of an individual is
#'
#' | Status | Description                    |
#' | -----: | :----------------------------- |
#' |     -2 | Dead                           |
#' |     -1 | Healed                         |
#' |      0 | Susceptible                    |
#' |      1 | Infected, not showing symptoms |
#' |      2 | Infected, showing symptoms     |
#' |      3 | Critical                       |
#' |     32 | 0 but isolated                 |
#' |     33 | 1 but isolated                 |
#'
#' @md
#'
#'
#' @export


simulate_sa2 <- function(days_to_simulate = 5,
                         PolicyPars = set_policypars(),
                         MultiPolicy = NULL,
                         EpiPars = set_epipars(),
                         InitialStatus = NULL,
                         .first_day = NULL,
                         showProgress = 1L,
                         dataEnv = getOption("covid19.model.sa2_dataEnv", new.env()),
                         use_dataEnv = getOption("covid19.model.sa2_useDataEnv", FALSE),
                         nThread = getOption("covid19.model.sa2_nThread", 1L),
                         myaus = NULL,
                         returner = 0L) {
  nThread <- checkmate::assert_int(nThread, lower = 1L, coerce = TRUE)
  fst::threads_fst(nThread)
  data.table::setDTthreads(nThread)

  .showProgress <- showProgress > 0
  if (showProgress == 1L) {
    .showProgress <- interactive() && isnt_testing()
  }
  prev_fst2_opt <- getOption("covid19.model.sa2.fst2_progress")

  .fst_progress <-
    (showProgress == 3) ||
    (showProgress == 2 && isTRUE(getOption("covid19.model.sa2.fst2_progress")))

  options("covid19.model.sa2.fst2_progress" = .fst_progress)
  on.exit({
    options(covid19.model.sa2.fst2_progress = prev_fst2_opt)
  })

  hh_ss <- function (x. = "", form = "%H:%M:%OS3") {
    if (.showProgress) {
      cat(as.character(format(Sys.time(), format = form)), x., "\n")
    } else {
      invisible(NULL)
    }
  }
  hh_ss("Start\t")

  Policy <- PolicyPars
  if (length(.first_day) > 1) {
    stop(g("`.first_day` had length {length(.first_day)}, but must be length-one."))
  }

  if (is.null(.first_day)) {
    .first_day <- yday(read_last("time_series_cases.fst", "Date"))
  } else if (!is.integer(.first_day)) {
    .first_day <- yday(.first_day)
  }

  updateLemireSeedFromR()

  if (is.null(myaus)) {
    aus <- generate_static_aus(use_dataEnv, nThread = nThread)

    if (hasName(aus, "Incubation")) {
      aus[, "Incubation" := NULL]
    }
    if (hasName(aus, "Illness")) {
      aus[, "Illness" := NULL]
    }

    Incubation <-
      with(EpiPars, {
        m <- incubation_mean
        s <- incubation_sigma
        switch(distrs()[incubation_distribution],
               "pois" = rep_len(rpois(131059, m), nrow(aus)),
               "lnorm" = rep_len(as.integer(rlnorm(131059, m, s), nrow(aus))),
               "dirac" = rep_len(as.integer(m, s), nrow(aus)),
               "cauchy" = RCauchy(do_lemire_rand_par(nrow(aus),
                                                     nThread = pmin.int(20L, nThread)),
                                  location = m,
                                  scale = s,
                                  nThread = pmin.int(20L, nThread)),
               stop("Internal error(Incubation): ", distrs()[.subset2(Epi, "incubation_distribution")],
                    " was unexpected at this time."))
      })

    Illness <-
      with(EpiPars, {
        m <- illness_mean
        s <- illness_sigma
        switch(distrs()[illness_distribution],
               "pois" = rep_len(rpois(131063, m), nrow(aus)),
               "lnorm" = rep_len(as.integer(rlnorm(131063, m, s), nrow(aus))),
               "dirac" = rep_len(as.integer(m, s), nrow(aus)),
               "cauchy" = RCauchy(do_lemire_rand_par(nrow(aus), nThread = pmin.int(20L, nThread)),
                                  location = m,
                                  scale = s,
                                  nThread = pmin.int(20L, nThread)),
               stop("Internal error(Illness): ", distrs()[.subset2(Epi, "illness_distribution")],
                    " was unexpected at this time."))
      })


    aus[, "Incubation" := Incubation]
    aus[, "Illness" := Illness]


    mutate_Status_InfectedOn(aus,
                             InitialStatus = InitialStatus,
                             yday_initial = .first_day,
                             nThread = nThread)
  } else {
    stopifnot(is.data.table(myaus),
              hasName(myaus, "Status"),
              hasName(myaus, "InfectedOn"),
              hasName(myaus, "sa2"),
              hasName(myaus, "short_dzn"),
              hasName(myaus, "nColleagues"),
              hasName(myaus, "Incubation"),
              hasName(myaus, "Illness"),
              hasName(myaus, "state"),
              hasName(myaus, "hid"),
              hasName(myaus, "pid"),
              hasName(myaus, "Age"))
    aus <- myaus
  }

  if (length(MultiPolicy) >= 255) {
    stop(g("`length(MultiPolicy) = {length(MultiPolicy)}`, which exceeds 255, ",
           "the largest supported number of policies."))
  }
  if (isTRUE(MultiPolicy) || identical(MultiPolicy, "historical")) {
    MultiPolicy <- set_multipolicy(.first_day)
  }

  copied_Status <- (.subset2(aus, "Status"))
  copied_InfectedOn <- (.subset2(aus, "InfectedOn"))


  on_terminal <- identical(.Platform$GUI, "RTerm")


  hh_ss("pre-C++")
  out <-
    with(aus,
         do_au_simulate(Status = copied_Status,
                        InfectedOn = copied_InfectedOn,
                        SA2 = sa2,
                        DZN = short_dzn,
                        wid = wid,
                        nColleagues = nColleagues,
                        hid = hid,
                        Age = Age,
                        School = short_school_id,
                        PlaceTypeBySA2 = integer(0),
                        LabourForceStatus = LabourForceStatus,
                        SeedOriginal = unlist(dqrng::generateSeedVectors(42)), # must be at least 20 to support 20 threads
                        Policy = Policy,
                        MultiPolicy = MultiPolicy %||% list(),
                        Epi = EpiPars,
                        Incubation = Incubation,
                        Illness = Illness,
                        nSupermarketsAvbl = nSupermarketsAvbl,
                        SupermarketTypical = SupermarketTypical,
                        nPlacesByDestType = get_nPlacesByDestType(),
                        minPlaceID_nPlacesByDestType = copy(minPlaceID_nPlacesByDestType),
                        yday_start = .first_day,
                        days_to_sim = days_to_simulate,
                        N = nrow(aus),
                        returner = returner,
                        display_progress = .showProgress,
                        on_terminal = on_terminal,
                        console_width = getOption("width", 80L),
                        optionz = getOption("optionz", 0L),  # for debugging may be changed without notice
                        nThread = nThread))

  hh_ss("final")
  if (returner) {
    if (returner == 1L) {
      DT <- data.table(N = out[[1]])
      DT[, "Status" := rep_len(c("Killed", "Healed", "Suscep", "NoSymp", "InSymp", "Critic", "Isolated"), .N)]
      DT[, "Day" := rep(seq_len(days_to_simulate), each = 7L)]
      hutils::set_cols_first(DT, c("Day", "Status"))
      return(DT)
    }
    if (returner == 2) {
      NN <- out[[1]]
      DT <- CJ(Day = seq_len(days_to_simulate),
               State = states()[2:10],
               Status = c("Killed", "Healed", "Suscep", "NoSymp", "InSymp", "Critic", "Isolated"),
               sorted = FALSE)
      if (nrow(DT) != length(NN)) {
        warning("Internal error: returning components separately.")
        return(invisible(list(DT = DT, NN = NN)))
      }
      DT[, "N" := NN]
      return(DT)
    }

    return(out)
  }


  out <- copy(out)

  # Rcpp doesn't put (any) names on the push_back
  setnames(setDT(out[[2]]), paste0("V", seq_along(out[[2]])))
  setnames(out[[2]], tail(names(out[[2]]), 2), c("InfectedOn", "Source"))


  # Put aus back into the statuses
  for (j in names(aus)) {
    if (j %in% c("InfectedOn")) {
      next
    }
    set(out[[2]], j = j, value = aus[[j]])
  }
  hutils::set_cols_first(out[[2]], names(aus))
  out
}








generate_static_aus <- function(use_dataEnv = TRUE, nThread = 1L) {
  if (isTRUE(use_dataEnv) &&
      exists("aus", envir = getOption("covid19.model.sa2_dataEnv"))) {
    return(read_dataEnv("aus"))
  }


  aus <- read_sys("australia.fst")

  nSupermarkets_by_sa2 <- read_sys("nSupermarkets_by_sa2.fst")

  demo_by_person <- read_sys("person_demography.fst")
  demo_by_person[, lfsi := ematch(as.character(lfs),
                                  c("Not applicable",
                                    "Not working",
                                    "Employed, worked full-time",
                                    "Employed, worked part-time"))]
  demo_by_person[, lfsi := lfsi - 2L]
  demo_by_person[, lfs := NULL]

  if (!hasName(aus, "Age") || !hasName(aus, "LabourForceStatus")) {
    Age <- i.age <- LabourForceStatus <- lfsi <- i.lfsi <- NULL
    if (identical(aus$pid, demo_by_person$pid)) {
      # save a couple a seconds
      set(aus, j = "Age", value = .subset2(demo_by_person, "age"))
      set(aus, j = "LabourForceStatus", value = .subset2(demo_by_person, "lfsi"))
    } else {
      aus[demo_by_person, Age := i.age, on = "pid"]
      aus[demo_by_person, LabourForceStatus := i.lfsi, on = "pid"]
    }
  }


  i.nSupermarkets <- nSupermarketsAvbl <- SupermarketTypical <- SupermarketHour <- NULL
  # Quicker to do it this way(!)
  aus[nSupermarkets_by_sa2, nSupermarketsAvbl := pmin.int(8L, i.nSupermarkets), on = "sa2"]

  # Choose a default supermarket for each person
  aus[, SupermarketTypical := if (.BY[[1]]) samp(seq_len(.BY[[1]]) - 1L, size = .N) else 0L,
      by = "nSupermarketsAvbl"]

  short_school_id <- short_dzn <- NULL
  # Turn School Id into short id to use for school id
  # Crucially, must be dense (no gaps) so can't prepare unique
  aus[!is.na(school_id), short_school_id := frank(school_id, ties.method = "dense")]
  aus[!is.na(work_dzn) , short_dzn := frank(work_dzn, ties.method = "dense")]

  # Add colleagues and wid (work id)
  wid <- nColleagues <- i.nColleagues <- i.wid <- NULL
  AusByDZN <- aus[!is.na(short_dzn), .(NDz = .N, pid, LabourForceStatus), keyby = .(dzn = short_dzn)]
  AusByDZN[, c("wid", "nColleagues") := do_workplaces(.SD, nThread = nThread)]

  # check against compile-time constant wid_supremum to allow
  # static allocation of array.
  wid_supremum_repeat_limit <- 5L
  while (wid_supremum_repeat_limit >= 0L &&
         max(.subset2(AusByDZN, "wid"), na.rm = TRUE) >= wid_supremum()) {
    AusByDZN[, c("wid", "nColleagues") := do_workplaces(.SD, nThread = nThread)]
    wid_supremum_repeat_limit <- wid_supremum_repeat_limit - 1L
  }
  if (max(.subset2(AusByDZN, "wid"), na.rm = TRUE) >= wid_supremum()) {
    stop("`wid_supremum_repeat_limit` exceeded\n\t",
         'max(.subset2(AusByDZN, "wid"), na.rm = TRUE) = ',
         max(.subset2(AusByDZN, "wid"), na.rm = TRUE))
  }


  setkeyv(AusByDZN, "pid")
  aus[AusByDZN, wid := i.wid, on = "pid"]
  aus[AusByDZN, nColleagues := i.nColleagues, on = "pid"]

  aus[, "school_id" := NULL]
  aus[, "work_dzn" := NULL]

  assign("aus",
         value = copy(aus),
         envir = getOption("covid19.model.sa2_dataEnv"))


  aus
}

mutate_Status_InfectedOn <- function(aus,
                                     InitialStatus = NULL,
                                     yday_initial = NULL,
                                     asympto = 0.48,
                                     p_critical = 0.03,
                                     nThread = getOption("covid19.model.sa2_nThread")) {

  stopifnot(hasName(aus, "state"),
            hasName(aus, "Incubation"),
            hasName(aus, "Illness"),
            is.integer(aus[["state"]]),
            !hutilscpp::anyOutside(aus[["state"]], 1L, 9L))

  hutils::drop_cols(aus, c("Status", "InfectedOn"))

  if (is.null(InitialStatus)) {
    set_initial_stochastic(aus, yday_initial, nThread = nThread)
    return(aus)
  } else {
    if (!is.integer(yday_initial)) {
      stop("`InitialStatus` is used, but `yday_initial` is not set.")
    }

    if (!is.data.table(InitialStatus)) {
      InitialStatus <- as.data.table(InitialStatus)
    }
    stopifnot(all(c("state", "active", "dead", "healed", "critical") %in% names(InitialStatus)),
              InitialStatus[, !anyDuplicated(state)],
              InitialStatus[, !anyNA(state)])


    switch(InitialStatus[, typeof(state)],
           "double" = {
             if (InitialStatus[, !all(state == as.integer(state))] ||
                 InitialStatus[, hutilscpp::anyOutside(state, 1, 9, nas_absent = TRUE)]) {
               stop("InitialStatus$state was type double but not all entries were whole numbers ",
                    " between 1 and 9.")
             }
             InitialStatus[, state := as.integer(state)]
           },
           "character" = {
             InitialStatus[, state := match(state, states()[-1])]
             InitialStatus[, stopifnot(!anyNA(state), !hutilscpp::anyOutside(state, 1L, 9L, nas_absent = TRUE))]
           })

    # Expand (omitted states are allowed)
    InitialStatus <- InitialStatus[CJ(state = 1:9), on = "state"][, lapply(.SD, as.integer)]
    InitialStatus <- InitialStatus[, lapply(.SD, coalesce, 0L), keyby = "state"]


    StatusByState <-
      InitialStatus[, .(Status = set_initial_by_state(.BY[[1]],
                                                      dead = first(dead),
                                                      healed = first(healed),
                                                      active = first(active),
                                                      critical = first(critical))),
                    keyby = .(state)]
    StatusByState <- StatusByState[CJ(state = 1:9), on = "state"]

    # At this point we should be able to just plonk the status in
    stopifnot(haskey(aus), identical(key(aus)[1], "state"),
              nrow(aus) == nrow(StatusByState))


    aus[, Status := .subset2(StatusByState, "Status")]



  }



  # Now set the yday when each individual was infected

  aus[, InfectedOn := NA_integer_]
  aus[, InfectedOn := fifelse(Status == status_nosymp(),

                              # Assume those we observe represnt half
                              # of those infected concurrently
                              yday_initial - (Incubation %/% 2L) - 1L,
                              InfectedOn)]
  aus[, InfectedOn := fifelse(or3s(Status == status_insymp(),
                                   Status == status_critic()),
                              yday_initial - Incubation - (Illness %/% 2L),
                              InfectedOn)]

  aus
}

get_nPlacesByDestType <- function() {
  if (exists("nPlacesByDestType", envir = getOption("covid19.model.sa2_dataEnv"))) {
    return(read_dataEnv("nPlacesByDestType"))
  }

  nPlacesByDestType <-
    lapply(1:106, function(i) {
      if (i == 98L) {
        read_sys("nSupermarkets_by_sa2.fst",
                 columns = "nSupermarkets")[[1L]]
      } else {
        integer(0)
      }
    })
  assign("nPlacesByDestType", value = nPlacesByDestType, envir = getOption("covid19.model.sa2_dataEnv"))
  nPlacesByDestType
}





