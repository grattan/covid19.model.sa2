#' Simulate the spread of COVID-19 through Australia
#' @description
#' Simulates the spread of COVID-19 given today's condition, and
#' the (imputed) distribution of indivdiuals among households,
#' schools, and other places, from day to day.
#'
#'
#' @param days_to_simulate \describe{
#' \item{\code{integer(1)}}{The number of days to simulate.}
#' }
#' @param InitialStatus \describe{
#' \item{\code{list(4)}}{A list of four named components giving the
#' number of dead, healed, active, and critical on the day zero.}
#' }
#' @param PolicyPars \describe{
#' \item{\code{list()}}{A list describing the policy parameters.
#' (\code{list(schools_open = TRUE|FALSE, only_Year12 = TRUE|FALSE)}
#' are supported but no others. An empty list corresponds to current settings.)}
#' }
#' @param EpiPars \describe{
#' \item{\code{list()}}{A list of epidemiological parameters generated by \code{\link{set_epipars}}.}
#' }
#' @param .first_day \describe{
#' \item{\code{integer(1)}}{The first day to model.
#' If \code{NULL}, the default, the day of the year of the most recent date
#' in records from Australia. Used to predict the outcomes of those presently
#' ill with COVID-19 based on imputed duration of infection.}
#' }
#' @param showProgress Should progress times and bars be displayed?
#' By default, 1 which displays bars unless it is likely to not be
#' desired (for example it won't be displayed when running tests or
#' in non-interactive sessions). Set to 0 to never display; 2 to always
#' display. Set to 3 to also show internal data access.
#'
#' @param by_state Set the initial status by state.
#'
#' @param dataEnv An environment into which the data will be saved and
#' retrieved. Used to save time reading after the first time.
#'
#' @param use_dataEnv \code{FALSE|TRUE} Whether or not to save the
#' underlying Australia table to \code{dataEnv} (and retrieve it on
#' subsequent uses).
#'
#' @param nThread \describe{
#' \item{\code{integer(1)}}{Number of threads to use in the C++ code.}
#' }
#'
#' @param myaus A prepared \code{data.table} with a column \code{status}
#' that has the desired distribution (including perhaps over SA2). This
#' formal is experimental and may be removed without notice.
#'
#' @param returner What values to return.
#' \describe{
#' \item{\code{0}}{The default, return the full data: status of each person, each day.}
#' \item{\code{1}}{\code{days} x \code{state} x \code{age} x \code{status}.}
#' }
#'
#' @return
#' A list of \code{days_to_simulate + 1} components. The first
#' component is the inital status of each individual and
#' subsequent components are the statuses of each day simulated.
#'
#' @details
#' The \strong{Status} of an individual is
#'
#' | Status | Description                    |
#' | -----: | :----------------------------- |
#' |     -2 | Dead                           |
#' |     -1 | Healed                         |
#' |      0 | Susceptible                    |
#' |      1 | Infected, not showing symptoms |
#' |      2 | Infected, showing symptoms     |
#' |      3 | Critical                       |
#' |     32 | 0 but isolated                 |
#' |     33 | 1 but isolated                 |
#'
#' @md
#'
#'
#' @export


simulate_sa2 <- function(days_to_simulate = 5,
                         PolicyPars = set_policypars(),
                         EpiPars = set_epipars(),
                         InitialStatus = list(dead = 71,
                                              healed = 4685,
                                              active = 1840,
                                              critical = 49),
                         .first_day = NULL,
                         showProgress = 1L,
                         by_state = TRUE,
                         dataEnv = getOption("covid19.model.sa2_dataEnv", new.env()),
                         use_dataEnv = getOption("covid19.model.sa2_useDataEnv", FALSE),
                         nThread = getOption("covid19.model.sa2_nThread", 1L),
                         myaus = NULL,
                         returner = 0L) {
  nThread <- checkmate::assert_int(nThread, lower = 1L, coerce = TRUE)
  fst::threads_fst(nThread)
  data.table::setDTthreads(nThread)

  .showProgress <- showProgress > 0
  if (showProgress == 1L) {
    .showProgress <- interactive() && isnt_testing()
  }
  prev_fst2_opt <- getOption("covid19.model.sa2.fst2_progress")

  .fst_progress <-
    (showProgress == 3) ||
    (showProgress == 2 && isTRUE(getOption("covid19.model.sa2.fst2_progress")))

  options("covid19.model.sa2.fst2_progress" = .fst_progress)
  on.exit({
    options(covid19.model.sa2.fst2_progress = prev_fst2_opt)
  })

  hh_ss <- function (x. = "", form = "%H:%M:%OS3") {
    if (.showProgress) {
      cat(as.character(format(Sys.time(), format = form)), x., "\n")
    } else {
      invisible(NULL)
    }
  }

  Policy  <- PolicyPars
  if (!isTRUE(use_dataEnv) ||
      !identical(by_state, get0("_by_state_", envir = dataEnv)) ||
      !identical(InitialStatus, get0("_InitialStatus_", envir = dataEnv)) ||
      is.null(aus <- get0("aus_", envir = dataEnv)) ||
      is.null(nPlacesByDestType <- get0("nPlacesByDestType_", envir = dataEnv)) ||
      # is.null(FreqsByDestType <- get0("FreqsByDestType_", envir = dataEnv)) ||
      XOR(is.null(.first_day), is.null(..first_day <- get0(".first_day_", envir = dataEnv)))) {

    # CRAN NOTE AVOIDANCE
    Date <- VIC <- i.VIC <- VicCases <-
      VicRecovered <- Concluded <-
      VicDeaths <- NewCases <- dConcluded <-
      VicActive <- Yday <- Duration <-
      YdayOut <- YdayIn <- Status <- NULL

    ## Each day a person can
    ## stay in the household
    ## journey outside
    ## be admitted to hospital etsq

    ## if a person journeys out they do so for a purpose
    ## they can move to a different SA2
    ## or they can move for a daily activity

    ## if they go out for work
    ## their destination is their dzn of work
    ## unless they are work in a hospital, school, or aged care

    ## if they go out for school as a pupil
    ## (only occurs if they are a child)
    ## they go to a school in their SA2

    ## if they go out to purchase groceries
    ## the destination is stochastic
    ## Other places by predefined times
    ## per year

    ## Only interested in magnitude of interactions
    ## (above a certain limit?)

    ## Process is
    ## Loop over each day
    ### Loop over each person
    #### identify their places that day
    ### add up all the interactions
    ### sleep!
    ### next day



    hh_ss("Start\t")

    aus <- read_sys("australia.fst")

    nSupermarkets_by_sa2 <- read_sys("nSupermarkets_by_sa2.fst")

    demo_by_person <- read_sys("person_demography.fst")
    demo_by_person[, lfsi := ematch(as.character(lfs),
                                    c("Not applicable",
                                      "Not working",
                                      "Employed, worked full-time",
                                      "Employed, worked part-time"))]
    demo_by_person[, lfsi := lfsi - 2L]
    demo_by_person[, lfs := NULL]

    Cases.csv <- read_sys("time_series_cases.fst")
    Recovered.csv <- read_sys("time_series_recovered.fst")
    Deaths.csv <- read_sys("time_series_deaths.fst")

    if (is.null(.first_day)) {
      .first_day <- Deaths.csv[, yday(last(Date))]
    } else {
      if (!is.integer(.first_day)) {
        .first_day <- yday(.first_day)
      }

      Cases.csv <- Cases.csv[yday(Date) <= .first_day]
      Recovered.csv <- Recovered.csv[yday(Date) <= .first_day]
      Deaths.csv <- Deaths.csv[yday(Date) <= .first_day]
    }

    hh_ss("post-read")

    diff_along <- function(x) c(NA, diff(x))

    # Use Victoria to get good idea about the duration of current cases
    Victoria <-
      Cases.csv %>%
      .[Recovered.csv] %>%
      .[, .(Date, VicCases = VIC, VicRecovered = coalesce(i.VIC, 0L))] %>%
      .[Deaths.csv] %>%
      .[, .(Date, VicCases, VicRecovered, VicDeaths = coalesce(VIC, 0L))] %>%
      .[, Date := as.Date(Date)] %>%
      .[, Concluded := VicRecovered + VicDeaths] %>%
      .[, Concluded := cummax(Concluded)] %>%  # protect against falls in reports
      .[, NewCases := diff_along(VicCases)] %>%
      .[, dConcluded := diff_along(Concluded)] %>%
      .[-1] %>%
      .[, VicActive := cumsum(NewCases) - cumsum(dConcluded)] %>%
      .[, Yday := yday(Date)]

    n_concluded_cases <- Victoria[, last(VicRecovered)]
    # One row for every (concluded) cases
    # Note it's not clear whether the very early cases' recovery
    # was recorded, so we exclude the first cases under the assumption
    # that their recovery was not recorded (else we get ~50 day
    # spells of illness).

    N_by_Duration <-
      data.table(YdayIn  = weight2rows(Victoria, "NewCases")[["Yday"]][seq_len(n_concluded_cases)],
                 YdayOut = weight2rows(Victoria, "dConcluded")[["Yday"]][seq_len(n_concluded_cases)]) %>%
      .[, Duration := YdayOut - YdayIn] %>%
      # Exclude Jan/early Feb cases
      .[YdayIn > 33] %>%
      .[, .N, keyby = .(Duration)]



    if (is.data.table(myaus)) {
      aus <- copy(myaus)
    } else if (by_state) {
      aus[, Status := set_initial_by_state(state)]
    } else  {
      asympto <- EpiPars$p_asympto / 1000
      sympto <- 1 - asympto

      # For text width
      IS <- InitialStatus
      n_status0 <- nrow(aus) - sum(unlist(IS))
      samp_status <-
        wsamp(c(-2L, -1L, 0L, 1L, 2L, 3L),
              size = nrow(aus),
              w = c(IS$dead, IS$healed, n_status0, IS$active * c(asympto, sympto), IS$critical))
      aus[, Status := samp_status]
    }

    InfectedOn <- NULL
    # If infected, they are infected days ago
    # according to N_by_Duration
    aus[Status > 0L,
        InfectedOn := .first_day - wsamp(N_by_Duration$Duration,
                                         size = .N,
                                         w = N_by_Duration$N)]


    Age <- i.age <- LabourForceStatus <- lfsi <- i.lfsi <- NULL
    if (identical(aus$pid, demo_by_person$pid)) {
      # save a couple a seconds
      set(aus, j = "Age", value = .subset2(demo_by_person, "age"))
      set(aus, j = "LabourForceStatus", value = .subset2(demo_by_person, "lfsi"))
    } else {
      aus[demo_by_person, Age := i.age, on = "pid"]
      aus[demo_by_person, LabourForceStatus := i.lfsi, on = "pid"]
    }

    nPlacesByDestType <-
      lapply(1:106, function(i) {
        if (i == 98L) {
          read_sys("nSupermarkets_by_sa2.fst",
                   columns = "nSupermarkets")[[1L]]
        } else {
          integer(0)
        }
      })
    #
    # # Times per year each person visits the matching type
    # weekly <- rep_len(52L, nrow(aus))
    #
    # FreqsByDestType <-
    #   lapply(1:106, function(i) {
    #     if (i == 15L) {
    #       # cafes
    #       # assume uniformly n/week
    #       cafe <- 52L * (0:7)
    #       return(dqrng::dqsample(cafe, size = 1e6, replace = TRUE))
    #     }
    #     if (i == 98L) {
    #       ## Assume supermarket visits are beta distributed
    #       rep_len(as.integer(360 * rbeta(1e6, 3, 1)), nrow(aus))
    #     } else {
    #       weekly
    #     }
    #   })
    #
    # FreqsByDestType <-
    #   lapply(FreqsByDestType, function(x) rep_len(as.integer(x), nrow(aus)))



    i.nSupermarkets <- nSupermarketsAvbl <- SupermarketTypical <- SupermarketHour <- NULL
    # Quicker to do it this way(!)
    aus[nSupermarkets_by_sa2, nSupermarketsAvbl := pmin.int(8L, i.nSupermarkets), on = "sa2"]

    # Choose a default supermarket for each person
    aus[, SupermarketTypical := if (.BY[[1]]) samp(seq_len(.BY[[1]]) - 1L, size = .N) else 0L,
        by = "nSupermarketsAvbl"]

    short_school_id <- short_dzn <- NULL
    # Turn School Id into short id to use for school id
    # Crucially, must be dense (no gaps) so can't prepare unique
    aus[!is.na(school_id), short_school_id := frank(school_id, ties.method = "dense")]
    aus[!is.na(work_dzn) , short_dzn := frank(work_dzn, ties.method = "dense")]

    # Add colleagues and wid (work id)
    wid <- nColleagues <- i.nColleagues <- i.wid <- NULL
    AusByDZN <- aus[!is.na(short_dzn), .(NDz = .N, pid, LabourForceStatus), keyby = .(dzn = short_dzn)]
    AusByDZN[, c("wid", "nColleagues") := do_workplaces(.SD, nThread = nThread)]

    # check against compile-time constant wid_supremum to allow
    # static allocation of array.
    wid_supremum_repeat_limit <- 5L
    while (wid_supremum_repeat_limit >= 0L &&
           max(.subset2(AusByDZN, "wid"), na.rm = TRUE) >= wid_supremum()) {
      AusByDZN[, c("wid", "nColleagues") := do_workplaces(.SD, nThread = nThread)]
      wid_supremum_repeat_limit <- wid_supremum_repeat_limit - 1L
    }
    if (max(.subset2(AusByDZN, "wid"), na.rm = TRUE) >= wid_supremum()) {
      stop("`wid_supremum_repeat_limit` exceeded\n\t",
           'max(.subset2(AusByDZN, "wid"), na.rm = TRUE) = ',
           max(.subset2(AusByDZN, "wid"), na.rm = TRUE))
    }


    setkeyv(AusByDZN, "pid")
    aus[AusByDZN, wid := i.wid, on = "pid"]
    aus[AusByDZN, nColleagues := i.nColleagues, on = "pid"]

    # from Stevenson-Lancet-COVID19.md
    # aus[, Incubation := dq_rnlorm(.N, m = EpiPars[["incubation_m"]], s = 0.44)]
    # aus[, Illness := dq_rnlorm(.N, m = EpiPars[["illness_m"]], s = 0.99)]

    if (isTRUE(use_dataEnv)) {
      assign("_by_state_", value = copy(by_state), envir = dataEnv)
      assign("_InitialStatus_", value = copy(InitialStatus), envir = dataEnv)
      assign("aus_", value = copy(aus), envir = dataEnv)
      assign("nPlacesByDestType_", value = nPlacesByDestType, envir = dataEnv)
      # assign("FreqsByDestType_", value = FreqsByDestType, envir = dataEnv)
      assign(".first_day_", value = .first_day, envir = dataEnv)
    }
    ..first_day <- .first_day
  }



  copied_Status <- (.subset2(aus, "Status"))
  copied_InfectedOn <- (.subset2(aus, "InfectedOn"))


  on_terminal <- identical(.Platform$GUI, "RTerm")

  Incubation <-
    with(EpiPars, {
      m <- incubation_mean
      s <- incubation_sigma
      switch(distrs()[incubation_distribution],
             "pois" = rep_len(rpois(131059, m), nrow(aus)),
             "lnorm" = rep_len(as.integer(rlnorm(131059, m, s), nrow(aus))),
             "dirac" = rep_len(as.integer(m, s), nrow(aus)),
             "cauchy" = RCauchy(do_lemire_rand_par(nrow(aus), copy(.Random.seed), nThread = pmin.int(20L, nThread)),
                                location = m,
                                scale = s,
                                nThread = pmin.int(20L, nThread)),
             stop("Internal error(Incubation): ", distrs()[.subset2(Epi, "incubation_distribution")],
                  " was unexpected at this time."))
    })

  Illness <-
    with(EpiPars, {
      m <- illness_mean
      s <- illness_sigma
      switch(distrs()[illness_distribution],
             "pois" = rep_len(rpois(131063, m), nrow(aus)),
             "lnorm" = rep_len(as.integer(rlnorm(131063, m, s), nrow(aus))),
             "dirac" = rep_len(as.integer(m, s), nrow(aus)),
             "cauchy" = RCauchy(do_lemire_rand_par(nrow(aus), copy(.Random.seed), nThread = pmin.int(20L, nThread)),
                                location = m,
                                scale = s,
                                nThread = pmin.int(20L, nThread)),
             stop("Internal error(Illness): ", distrs()[.subset2(Epi, "illness_distribution")],
                  " was unexpected at this time."))
    })

  hh_ss("pre-C++")
  out <-
    with(aus,
         do_au_simulate(Status = copied_Status,
                        InfectedOn = copied_InfectedOn,
                        SA2 = sa2,
                        DZN = short_dzn,
                        wid = wid,
                        nColleagues = nColleagues,
                        hid = hid,
                        Age = Age,
                        School = short_school_id,
                        PlaceTypeBySA2 = integer(0),
                        LabourForceStatus = LabourForceStatus,
                        SeedOriginal = c(0L, .Random.seed),
                        Policy = Policy,
                        Epi = EpiPars,
                        Incubation = Incubation,
                        Illness = Illness,
                        nSupermarketsAvbl = nSupermarketsAvbl,
                        SupermarketTypical = SupermarketTypical,
                        nPlacesByDestType = nPlacesByDestType,
                        minPlaceID_nPlacesByDestType = copy(minPlaceID_nPlacesByDestType),
                        yday_start = ..first_day,
                        days_to_sim = days_to_simulate,
                        N = nrow(aus),
                        by_state = by_state,
                        returner = returner,
                        display_progress = .showProgress,
                        on_terminal = on_terminal,
                        console_width = getOption("width", 80L),
                        optionz = getOption("optionz", 0L),  # for debugging may be changed without notice
                        nThread = nThread))

  hh_ss("final")
  if (returner) {
    if (returner == 1L) {
      DT <- data.table(N = out[[1]])
      DT[, "Status" := rep_len(c("Killed", "Healed", "Suscep", "NoSymp", "InSymp", "Critic", "Isolated"), .N)]
      DT[, "Day" := rep(seq_len(days_to_simulate), each = 7L)]
      hutils::set_cols_first(DT, c("Day", "Status"))
      return(DT)
    }
    if (returner == 2) {
      NN <- out[[1]]
      DT <- CJ(Day = seq_len(days_to_simulate),
               State = states()[2:10],
               Status = c("Killed", "Healed", "Suscep", "NoSymp", "InSymp", "Critic", "Isolated"),
               sorted = FALSE)
      if (nrow(DT) != length(NN)) {
        warning("Internal error: returning components separately.")
        return(invisible(list(DT = DT, NN = NN)))
      }
      DT[, "N" := NN]
      return(DT)
    }
    if (returner == 3) {
      return(out[[1]])
    }
  }


  out <- copy(out)

  # Rcpp doesn't put (any) names on the push_back
  setnames(setDT(out[[2]]), paste0("V", seq_along(out[[2]])))

  # Put aus back into the statuses
  for (j in names(aus)) {
    set(out[[2]], j = j, value = aus[[j]])
  }
  hutils::set_cols_first(out[[2]], names(aus))
  out
}


